# Substreams `usdc-transfers`

## Protobuf defintion and produced database schema

### [contract.proto](substreams/usdc_transfers/proto/contract.proto) from the [usdc_transfers](substreams/usdc_transfers) substreams

```protobuf
syntax = "proto3";

import "google/protobuf/timestamp.proto";
import "sf/substreams/sink/sql/schema/v1/schema.proto";

package contract.v1;

message Output {
    repeated Transfer transfers =1;
}

message Transfer {
    option (schema.table) = {
        name: "transfers"
        clickhouse_table_options: {
            order_by_fields: [{name: "trx_hash"},  {name: "_block_number_"}, {name: "from"}, {name: "to"}]
            partition_fields: [{name: "_block_timestamp_", function: toYYYYMM}]
        }
    };

    string trx_hash = 1;
    bytes from = 5;
    bytes to = 6;
    string amount = 7 [(schema.field) = { convertTo: { uint256{} } }];
}
```

### Database Schema processed by substreams-sink-sql and [usdc_transfers](substreams/usdc_transfers) substreams

```sql
create table transfers._blocks_
(
    number    UInt64,
    hash      String,
    timestamp DateTime,
    version   Int64,
    deleted   Bool
)
ENGINE = ReplacingMergeTree(version)
PARTITION BY toYYYYMM(timestamp)
PRIMARY KEY number
ORDER BY number
SETTINGS index_granularity = 8192;

create table transfers.transfers
(
    _block_number_    UInt64,
    _block_timestamp_ DateTime,
    _version_         Int64,
    _deleted_         Bool,
    trx_hash          String,
    from              String,
    to                String,
    amount            UInt256
)
ENGINE = ReplacingMergeTree(_version_)
PARTITION BY toYYYYMM(_block_timestamp_)
ORDER BY (trx_hash, _block_number_, from, to)
SETTINGS index_granularity = 8192;
```

## Relation between the protobuf definition and the database schema

This section explains how the protobuf annotations drive the ClickHouse schema generated by substreams-sink-sql, and how each field maps to the final tables and columns.

### High-level flow:
- Your Substreams module emits messages of type contract.v1.Transfer.
- The (schema.table) option on the Transfer message tells substreams-sink-sql to materialize these messages into a ClickHouse table named transfers inside the target database (transfers in our examples).
- The sink automatically adds block-related metadata columns and uses a ReplacingMergeTree engine to handle chain reorgs and late data.

### Automatically added metadata columns:
- _block_number_ UInt64: the block number that produced the row.
- _block_timestamp_ DateTime: the block timestamp.
- _version_ Int64: a monotonically increasing value used by ReplacingMergeTree for deduplication/upserts.
- _deleted_ Bool: logical delete flag used to express undo operations during reorgs. Queries can filter WHERE _deleted_ = 0 for current rows, or use additive patterns (as shown in the materialized view) to account for both inserts and deletions.

### Table engine and options from protobuf:
- `option (schema.table).name = "transfers"`
  - Produces table transfers.transfers.
- `option (schema.table).clickhouse_table_options.order_by_fields`
  - Set the table ORDER BY (trx_hash, _block_number_, from, to)
  - This defines the sorting key used by ReplacingMergeTree for deduplication and efficient range queries.
- `option (schema.table).clickhouse_table_options.partition_fields`
  - partition_fields: [{ name: "_block_timestamp_", function: toYYYYMM }] → PARTITION BY toYYYYMM(_block_timestamp_)
  - This keeps data clustered by month, improving pruning and making it easy to manage monthly parts.
- Engine: `ReplacingMergeTree(_version_)`
  - Substreams-sink-sql uses ReplacingMergeTree with the _version_ column to reconcile multiple versions of the same logical row, which can happen due to chain reorgs.

### Blocks helper table (transfers._blocks_):
- The sink also creates and maintains a block-level table:
  - number UInt64, hash String, timestamp DateTime, version Int64, deleted Bool
  - ENGINE = ReplacingMergeTree(version)
  - PARTITION BY toYYYYMM(timestamp), ORDER BY number
- This table is useful for debugging or correlating rows back to blocks. The presence of deleted/version mirrors the same reorg-safe pattern used for the data tables.

### Resulting schema (as generated):
- transfers._blocks_ matches the definition shown above.
- transfers.transfers contains the four metadata columns plus the protobuf fields mapped to ClickHouse types, with ORDER BY and PARTITION BY derived from the protobuf table options.

Practical querying notes:
- Current-state queries typically add WHERE _deleted_ = 0.
- When aggregating over time and needing reorg-safe correctness, prefer patterns that add negative deltas for _deleted_ rows (as demonstrated in the materialized view below).

# Materialized View for Monthly Transfers

This section explains how to create and use a materialized view that stores pre-aggregated monthly metrics derived from the raw `transfers.transfers` table populated by `substreams-sink-sql`.

# Steps to create a materialized view

#### - Stop the substreams-sink-sql process
- Start clickhouse-client if you don’t already have one open:

```shell
docker exec -it clickehouse-showcase clickhouse-client --host 127.0.0.1
```

#### - Create the materialized view

```sql
CREATE MATERIALIZED VIEW transfers.monthly_transfers
    ENGINE = SummingMergeTree()
    PARTITION BY month
    ORDER BY month
AS
SELECT 
    toYYYYMM(_block_timestamp_)                             AS month,
    sum(if(_deleted_, -amount, amount)) AS volume,
    sum(if(_deleted_, -1, 1))                               AS transfer_count
FROM transfers.transfers
GROUP BY month;
```

#### - Populate (backfill) the materialized view

```sql
INSERT INTO transfers.monthly_transfers
SELECT
    toYYYYMM(_block_timestamp_)                             AS month,
    sum(if(_deleted_, -amount, amount)) AS volume,
    sum(if(_deleted_, -1, 1))                               AS transfer_count
FROM transfers.transfers
GROUP BY month;      
```

#### - Restart the substreams-sink-sql process

#### - Query the view

```sql
SELECT * FROM transfers.monthly_transfers FINAL;
```

## What is `transfers.monthly_transfers`?

This materialized view stores pre-aggregated monthly metrics derived from the raw `transfers.transfers` table populated by `substreams-sink-sql`.

What it contains:
- One row per calendar month (format YYYYMM from `_block_timestamp_`).
- Aggregated columns over that month:
  - `volume`: sum of transferred `amount` values as deltas.
  - `transfer_count`: number of transfers as deltas.

How it’s built and maintained:
- Engine: `SummingMergeTree()` with `ORDER BY month` and `PARTITION BY month`.
  - SummingMergeTree keeps additive aggregates efficiently. During background merges, rows with the same sorting key (`month`) are combined by summing numeric columns.
- The SELECT used by the view converts raw events to additive deltas:
  - For inserts (normal events), it adds `+amount` and `+1` to the monthly totals.
  - For deletions/undo events (`_deleted_ = 1`), it adds the opposite deltas: `-amount` and `-1`.
  - This ensures the monthly totals remain correct even with chain reorgs or late corrections emitted by Substreams.
- After creating the view, you backfill historical months with the provided `INSERT INTO ... SELECT ... GROUP BY month` statement. Once resumed, new inserts to `transfers.transfers` will automatically update the view.

Why queries use FINAL:
- With `SummingMergeTree`, background merges progressively combine rows for the same `month`. `FINAL` forces a read that returns fully summed values even if merges haven’t completed yet. It’s convenient for immediate correctness at the cost of some extra CPU. For large ranges you can often omit `FINAL` and rely on merges, or use an explicit `GROUP BY month` on the view if needed.

Operational tips:
- Backfilling: If you recreate the view, re-run the backfill INSERT to repopulate historical data.
- Idempotency: Because deltas include negative values for `_deleted_`, reprocessing or late-arriving deletions won’t double count; they adjust the totals.
- Performance: Partitioning by `month` keeps writes/reads efficient and makes it easy to drop or reprocess specific months if required.
